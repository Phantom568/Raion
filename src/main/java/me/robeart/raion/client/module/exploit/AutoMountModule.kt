package me.robeart.raion.client.module.exploit

import com.google.common.base.Predicate
import me.robeart.raion.client.events.events.network.PacketReceiveEvent
import me.robeart.raion.client.events.events.network.PacketSendEvent
import me.robeart.raion.client.events.events.player.UpdateWalkingPlayerEvent
import me.robeart.raion.client.module.Module
import me.robeart.raion.client.value.BooleanValue
import me.robeart.raion.client.value.FloatValue
import me.robeart.raion.client.value.kotlin.ValueDelegate
import net.minecraft.entity.Entity
import net.minecraft.entity.item.EntityBoat
import net.minecraft.entity.item.EntityMinecart
import net.minecraft.entity.passive.AbstractHorse
import net.minecraft.entity.passive.EntityPig
import net.minecraft.network.play.client.CPacketUseEntity
import net.minecraft.network.play.server.SPacketEntityStatus
import net.minecraft.network.play.server.SPacketEntityTeleport
import net.minecraft.network.play.server.SPacketSetPassengers
import net.minecraft.util.math.AxisAlignedBB
import team.stiff.pomelo.impl.annotated.handler.annotation.Listener

/**
 * @author cookiedragon234 17/May/2020
 */
object AutoMountModule: Module("AutoMount", "Automatically mounts nearby entities", Category.EXPLOIT) {
	val range by ValueDelegate(FloatValue("Range", 3.5f, 1f, 6f, 0.25f))
	val ignoreDismount by ValueDelegate(BooleanValue("Ignore Dismount", false))
	val mountNearby by ValueDelegate(BooleanValue("Mount Nearby", true))
	val clientSideMount by ValueDelegate(BooleanValue("Client Side mount", true))

	val ignore = HashSet<Entity>()

	override fun onDisable() {
		ignore.clear()
	}

	override fun onEnable() {
		ignore.clear()
	}

	@Listener
	private fun onPacketSend(event: PacketSendEvent) {
		if (clientSideMount) {
			val packet = event.packet
			if (packet is CPacketUseEntity && packet.action != CPacketUseEntity.Action.ATTACK) {
				event.isCanceled = true
			}
		}
	}

	@Listener
	private fun onPacketReceive(event: PacketReceiveEvent) {
		if (ignoreDismount) {
			val packet = event.packet
			if (packet is SPacketSetPassengers) {
				val entity = mc.world.getEntityByID(packet.entityId) ?: return
				ignore.remove(entity)
				if (entity == mc.player.ridingEntity) {
					event.isCanceled = true
				}
			} else if (packet is SPacketEntityStatus) {
				val entity = packet.getEntity(mc.world) ?: return
				ignore.remove(entity)
			} else if (packet is SPacketEntityTeleport) {
				val entity = mc.world.getEntityByID(packet.entityId) ?: return
				ignore.remove(entity)
			}
		}
	}

	@Listener
	private fun onUpdate(event: UpdateWalkingPlayerEvent) {
		if (mountNearby) {
			if (mc.player.isRiding) return

			val pos = mc.player.positionVector
			val range = this.range.toDouble()
			val bb = AxisAlignedBB(pos, pos).expand(range, range, range)
			val e = ridableEntitiesClosestToPlayer(bb).minBy { mc.player.getDistanceSq(it) } ?: return
			mc.player.startRiding(e, true)
			ignore.add(e)
		}
	}

	private fun ridableEntitiesClosestToPlayer(bb: AxisAlignedBB): MutableList<Entity> =
		mc.world.getEntitiesInAABBexcluding(mc.player, bb, CANRIDE_PREDICATE)

	@Suppress("ObjectLiteralToLambda") // Obfuscation breaks it
	private val CANRIDE_PREDICATE = object: Predicate<Entity?> {
		override fun apply(entity: Entity?): Boolean {
			return (entity != null
			&&
			(
				entity is EntityBoat
				||
				entity is EntityMinecart
				||
				entity is AbstractHorse
				||
				entity is EntityPig
			)
			&&
			!ignore.contains(entity))
		}
	}
}
